From 8f3f86200cfc9a0cc5f2e33d1954206b7016e9e4 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Mon, 7 Jun 2021 10:13:24 -0400
Subject: [PATCH 1/3] changing the restore topology routine to load the
 switches, interfaces and links on Kytos startup

---
 main.py | 199 ++++++++++++++++++++++----------------------------------
 1 file changed, 79 insertions(+), 120 deletions(-)

diff --git a/main.py b/main.py
index 70c7f28..85f0c3d 100644
--- a/main.py
+++ b/main.py
@@ -3,6 +3,7 @@
 Manage the network topology
 """
 import time
+from datetime import datetime, timezone
 
 from flask import jsonify, request
 from werkzeug.exceptions import BadRequest, UnsupportedMediaType
@@ -19,8 +20,6 @@
 from napps.kytos.topology.storehouse import StoreHouse
 
 DEFAULT_LINK_UP_TIMER = 10
-DEFAULT_INTERFACE_RESTORE_TIMER = 2
-RESTORE_INTERFACE_ATTEMPTS = 20
 
 
 class Main(KytosNApp):  # pylint: disable=too-many-public-methods
@@ -33,14 +32,8 @@ def setup(self):
         """Initialize the NApp's links list."""
         self.links = {}
         self.store_items = {}
-        self.switches_state = {}
-        self.interfaces_state = {}
-        self.links_state = {}
-        self._verified_links = []
         self.link_up_timer = getattr(settings, 'LINK_UP_TIMER',
                                      DEFAULT_LINK_UP_TIMER)
-        self.interface_restore = getattr(settings, 'INTERFACE_RESTORE_TIMER',
-                                         DEFAULT_INTERFACE_RESTORE_TIMER)
 
         self.verify_storehouse('switches')
         self.verify_storehouse('interfaces')
@@ -121,94 +114,67 @@ def _get_link_from_interface(self, interface):
                 return link
         return None
 
-    def _restore_link(self, link_id):
-        """Restore link's administrative state from storehouse."""
-        try:
-            state = self.links_state[link_id]
-        except KeyError:
-            error = (f'The link {link_id} has no stored '
-                     'administrative state to be restored.')
-            raise RestoreError(error)
-
-        try:
-            link = self.links[link_id]
-            if state['enabled']:
-                link.enable()
-            else:
-                link.disable()
-        except KeyError:
-            error = ('Error restoring link status.'
-                     f'The link {link_id} does not exist.')
-            raise RestoreError(error)
-        log.info(f'The state of link {link.id} has been restored.')
-        self.notify_topology_update()
-        self.update_instance_metadata(link)
-        self.notify_link_status_change(link)
-
-    def _restore_switch(self, switch_id):
-        """Restore switch's administrative state from storehouse."""
-        try:
-            state = self.switches_state[switch_id]
-        except KeyError:
-            error = (f'The switch {switch_id} has no stored'
-                     ' administrative state to be restored.')
-            raise RestoreError(error)
-
-        try:
-            switch = self.controller.switches[switch_id]
-        except KeyError:
-            # Maybe we should remove the switch from switches_state here
-            error = ('Error while restoring switches status. The '
-                     f'switch {switch_id} does not exist.')
-            raise RestoreError(error)
-
-        if state:
+    def _load_switch(self, switch_id, switch_att):
+        log.info(f'Loading switch from storehouse dpid={switch_id}')
+        switch = Switch(dpid=switch_id)
+        self.controller.add_new_switch(switch)
+        # workaround so switch.is_active() returns False
+        switch.lastseen = datetime(1, 1, 1, 0, 0, 0, 0, timezone.utc)
+        if switch_att['enabled']:
             switch.enable()
-            self.notify_switch_enabled(switch_id)
         else:
             switch.disable()
-            self.notify_switch_disabled(switch_id)
-
-        log.debug('Waiting to restore administrative state of switch '
-                  f'{switch_id} interfaces.')
-        i = 0
-        # wait to restore interfaces
-        while not switch.interfaces and i < RESTORE_INTERFACE_ATTEMPTS:
-            time.sleep(self.interface_restore)
-            i += 1
-        if not switch.interfaces:
-            error = ('Error restoring administrative state of switch '
-                     f'{switch_id} interfaces.')
-            raise RestoreError(error)
-
-        # restore interfaces
-        for interface_id in switch.interfaces:
-            iface_id = ":".join([switch_id, str(interface_id)])
-            # restore only the administrative state of saved interfaces
-            if iface_id not in self.interfaces_state:
-                error = ("The stored topology is different from the current "
-                         f"topology. The interface {iface_id} hasn't been "
-                         "stored.")
-                log.info(error)
-                continue
-            state = self.interfaces_state[iface_id]
-            iface_number = int(interface_id)
-            iface_status, lldp_status = state
-            try:
-                interface = switch.interfaces[iface_number]
-            except KeyError:
-                log.error('Error restoring interface status: '
-                          '%s does not exist.', iface_id)
-                continue
-
-            if iface_status:
+        switch.description['manufacturer'] = switch_att.get('manufacturer', '')
+        switch.description['hardware'] = switch_att.get('hardware', '')
+        switch.description['software'] = switch_att.get('software')
+        switch.description['serial'] = switch_att.get('serial', '')
+        switch.description['data_path'] = switch_att.get('data_path', '')
+        self.update_instance_metadata(switch)
+        for iface_id, iface_att in switch_att.get('interfaces', {}).items():
+            log.info(f'Loading interface iface_id={iface_id}')
+            interface = Interface(name=iface_att['name'],
+                                  port_number=iface_att['port_number'],
+                                  address=iface_att.get('mac', None),
+                                  speed=iface_att.get('speed', None),
+                                  switch=switch)
+            interface.deactivate()
+            if iface_att['enabled']:
                 interface.enable()
             else:
                 interface.disable()
-            interface.lldp = lldp_status
+            interface.lldp = iface_att['lldp']
+            switch.update_interface(interface)
             self.update_instance_metadata(interface)
 
-        log.info(f'The state of switch {switch_id} has been restored.')
+    def _load_link(self, link_att):
+        dpid_a = link_att['endpoint_a']['switch']
+        dpid_b = link_att['endpoint_b']['switch']
+        port_a = link_att['endpoint_a']['port_number']
+        port_b = link_att['endpoint_b']['port_number']
+        link_str = f'{dpid_a}:{port_a}-{dpid_b}:{port_b}'
+        log.info(f'Loading link from storehouse {link_str}')
+
+        try:
+            switch_a = self.controller.switches[dpid_a]
+            switch_b = self.controller.switches[dpid_b]
+            interface_a = switch_a.interfaces[port_a]
+            interface_b = switch_b.interfaces[port_b]
+        except Exception as err:
+            error = f'Fail to load endpoints for link {link_str}: {err}'
+            raise RestoreError(error)
+
+        link = self._get_link_or_create(interface_a, interface_b)
+
+        if link_att['enabled']:
+            link.enable()
+        else:
+            link.disable()
+
+        interface_a.update_link(link)
+        interface_b.update_link(link)
+        interface_a.nni = True
+        interface_b.nni = True
+        self.update_instance_metadata(link)
 
     # pylint: disable=attribute-defined-outside-init
     def _load_network_status(self):
@@ -216,26 +182,33 @@ def _load_network_status(self):
         try:
             status = self.storehouse.get_data()
         except FileNotFoundError as error:
-            log.info(error)
+            log.error(f'Fail to load network status from storehouse: {error}')
             return
-        if status:
-            switches = status['network_status']['switches']
-            self.links_state = status['network_status']['links']
-
-            for switch_id, switch_att in switches.items():
-                # get switches status
-                self.switches_state[switch_id] = switch_att['enabled']
-                iface = switch_att['interfaces']
-                # get interface status
-                for iface_id, iface_att in iface.items():
-                    enabled_value = iface_att['enabled']
-                    lldp_value = iface_att['lldp']
-                    self.interfaces_state[iface_id] = (enabled_value,
-                                                       lldp_value)
 
-        else:
-            error = 'There is no status saved to restore.'
-            log.info(error)
+        if not status:
+            log.info('There is no status saved to restore.')
+            return
+
+        switches = status['network_status']['switches']
+        links = status['network_status']['links']
+
+        log.debug("_load_network_status switches=%s" % switches)
+        for switch_id, switch_att in switches.items():
+            if switch_id not in self.controller.switches:
+                try:
+                    self._load_switch(switch_id, switch_att)
+                # pylint: disable=broad-except
+                except Exception as err:
+                    log.error(f'Error loading switch: {err}')
+
+        log.debug("_load_network_status links=%s" % links)
+        for link_id, link_att in links.items():
+            if link_id not in self.links:
+                try:
+                    self._load_link(link_att)
+                # pylint: disable=broad-except
+                except Exception as err:
+                    log.error(f'Error loading link: {err}')
 
     @rest('v3/')
     def get_topology(self):
@@ -245,18 +218,6 @@ def get_topology(self):
         """
         return jsonify(self._get_topology_dict())
 
-    def restore_network_status(self, obj):
-        """Restore the network administrative status saved in storehouse."""
-        try:
-            if isinstance(obj, Switch):
-                self._restore_switch(obj.id)
-            elif isinstance(obj, Link):
-                if obj.id not in self._verified_links:
-                    self._verified_links.append(obj.id)
-                    self._restore_link(obj.id)
-        except RestoreError as exc:
-            log.debug(exc)
-
     # Switch related methods
     @rest('v3/switches')
     def get_switches(self):
@@ -535,7 +496,6 @@ def handle_new_switch(self, event):
         log.debug('Switch %s added to the Topology.', switch.id)
         self.notify_topology_update()
         self.update_instance_metadata(switch)
-        self.restore_network_status(switch)
         if switch.is_enabled():
             self.notify_switch_enabled(switch.id)
 
@@ -679,7 +639,6 @@ def add_links(self, event):
         interface_b.nni = True
 
         self.notify_topology_update()
-        self.restore_network_status(link)
 
     # def add_host(self, event):
     #    """Update the topology with a new Host."""

From 5dfdc0bb2d7c46cc53bb43ababc37d4fa2e446c6 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Tue, 8 Jun 2021 22:47:50 -0400
Subject: [PATCH 2/3] cleaning up settings and adjusting unit tests

---
 settings.py             |   2 -
 tests/unit/test_main.py | 398 ++++++++++++++++++++++++++++++----------
 2 files changed, 305 insertions(+), 95 deletions(-)

diff --git a/settings.py b/settings.py
index f756511..290b26d 100644
--- a/settings.py
+++ b/settings.py
@@ -7,5 +7,3 @@
 LINK_UP_TIMER = 10
 # Time (in seconds) to wait retrieve box from storehouse
 BOX_RESTORE_TIMER = 0.1
-# Time (in seconds) to wait before restore interfaces
-INTERFACE_RESTORE_TIMER = 2
diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index 7d98502..3bd7704 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -190,138 +190,350 @@ def test_get_topology(self):
     @patch('napps.kytos.topology.main.StoreHouse.get_data')
     def test_load_network_status(self, mock_storehouse_get_data):
         """Test _load_network_status."""
+        link_id = \
+            'cf0f4071be426b3f745027f5d22bc61f8312ae86293c9b28e7e66015607a9260'
+        dpid_a = '00:00:00:00:00:00:00:01'
+        dpid_b = '00:00:00:00:00:00:00:02'
         status = {
             'network_status': {
                 'id': 'network_status',
                 'links': {
-                    '4d42dc08522': {
+                    link_id: {
                         'enabled': True,
                         'endpoint_a': {
-                            'switch': '00:00:00:00:00:00:00:01',
-                            'id': '00:00:00:00:00:00:00:00:1'
+                            'switch': dpid_a,
+                            'port_number': 2
                         },
                         'endpoint_b': {
-                            'switch': '00:00:00:00:00:00:00:01',
-                            'id': '00:00:00:00:00:00:00:00:2'
+                            'switch': dpid_b,
+                            'port_number': 2
                         }
                     }
                 },
                 'switches': {
-                    '00:00:00:00:00:00:00:01': {
-                        'dpid': '00:00:00:00:00:00:00:01',
+                    dpid_a: {
+                        'dpid': dpid_a,
                         'enabled': True,
-                        'id': '00:00:00:00:00:00:00:01',
+                        'id': dpid_a,
                         'interfaces': {
-                            '00:00:00:00:00:00:00:01:1': {
+                            f'{dpid_a}:2': {
                                 'enabled': True,
                                 'lldp': True,
-                                'id': '00:00:00:00:00:00:00:00:1',
+                                'port_number': 2,
+                                'name': 's1-eth2'
+                            }
+                        }
+                    },
+                    dpid_b: {
+                        'dpid': dpid_b,
+                        'enabled': True,
+                        'id': dpid_b,
+                        'interfaces': {
+                            f'{dpid_b}:2': {
+                                'enabled': True,
+                                'lldp': True,
+                                'port_number': 2,
+                                'name': 's2-eth2'
                             }
                         }
                     }
                 }
             }
         }
-        switches_expected = {'00:00:00:00:00:00:00:01': True}
-        interfaces_expected = {'00:00:00:00:00:00:00:01:1': (True, True)}
+        switches_expected = [dpid_a, dpid_b]
+        interfaces_expected = [f'{dpid_a}:2', f'{dpid_b}:2']
+        links_expected = [link_id]
         mock_storehouse_get_data.return_value = status
         self.napp._load_network_status()
-        self.assertDictEqual(switches_expected, self.napp.switches_state)
-        self.assertDictEqual(interfaces_expected, self.napp.interfaces_state)
-        self.assertDictEqual(status['network_status']['links'],
-                             self.napp.links_state)
-
-    # pylint: disable=too-many-locals
-    def test_restore_network_status(self):
-        """Test restore_network_status."""
-        dpid = '00:00:00:00:00:00:00:01'
-        mock_switch = get_switch_mock(dpid)
-        mock_switch.id = dpid
-        mock_interface = get_interface_mock('s1-eth1', 1, mock_switch)
-        mock_switch.interfaces = {1: mock_interface}
-        self.napp.controller.switches = {dpid: mock_switch}
-        self.napp.switches_state = {dpid: True}
-        self.napp.interfaces_state = {'00:00:00:00:00:00:00:01:1': (True,
-                                                                    True)}
+        self.assertListEqual(switches_expected,
+                             list(self.napp.controller.switches.keys()))
+        interfaces = []
+        for switch in self.napp.controller.switches.values():
+            for iface in switch.interfaces.values():
+                interfaces.append(iface.id)
+        self.assertListEqual(interfaces_expected, interfaces)
+        self.assertListEqual(links_expected, list(self.napp.links.keys()))
 
-        # enable
-        self.napp.restore_network_status(mock_switch)
-        self.assertEqual(mock_switch.enable.call_count, 1)
-        self.assertEqual(mock_interface.enable.call_count, 1)
-        self.assertEqual(mock_interface.lldp, True)
-
-        # disable
-        self.napp.switches_state = {dpid: False}
-        self.napp.interfaces_state = {'00:00:00:00:00:00:00:01:1': (False,
-                                                                    False)}
-        self.napp.restore_network_status(mock_switch)
-        self.assertEqual(mock_switch.disable.call_count, 1)
-        self.assertEqual(mock_interface.disable.call_count, 1)
-        self.assertEqual(mock_interface.lldp, False)
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_fail(self, *args):
+        """Test _load_network_status failure."""
+        (mock_log, mock_storehouse_get_data) = args
+        mock_log.error.return_value = True
+        mock_storehouse_get_data.side_effect = FileNotFoundError('xpto')
+        self.napp._load_network_status()
+        error = 'Fail to load network status from storehouse: xpto'
+        mock_log.error.assert_called_with(error)
 
-    def test_restore_links(self):
-        """Test restore_link."""
-        dpid = '00:00:00:00:00:00:00:01'
-        dpid_b = '00:00:00:00:00:00:00:02'
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_does_nothing(self, *args):
+        """Test _load_network_status doing nothing."""
+        (mock_log, mock_storehouse_get_data) = args
+        mock_log.info.return_value = True
+        mock_storehouse_get_data.return_value = {}
+        self.napp._load_network_status()
+        error = 'There is no status saved to restore.'
+        mock_log.info.assert_called_with(error)
+
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.Main._load_switch')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_fail_switch(self, *args):
+        """Test _load_network_status failure in switch."""
+        (mock_log, mock_load_switch, mock_get_data) = args
+        status = {
+            'network_status': {
+                'id': 'network_status',
+                'links': {},
+                'switches': {
+                    '1': {}
+                }
+            }
+        }
+        mock_log.error.return_value = True
+        mock_get_data.return_value = status
+        mock_load_switch.side_effect = Exception('xpto')
+        self.napp._load_network_status()
+        error = 'Error loading switch: xpto'
+        mock_log.error.assert_called_with(error)
+
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.Main._load_link')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_fail_link(self, *args):
+        """Test _load_network_status failure in link."""
+        (mock_log, mock_load_link, mock_get_data) = args
+        status = {
+            'network_status': {
+                'id': 'network_status',
+                'switches': {},
+                'links': {
+                    '1': {}
+                }
+            }
+        }
+        mock_log.error.return_value = True
+        mock_get_data.return_value = status
+        mock_load_link.side_effect = Exception('xpto')
+        self.napp._load_network_status()
+        error = 'Error loading link: xpto'
+        mock_log.error.assert_called_with(error)
+
+    def test_load_switch(self):
+        """Test _load_switch."""
+        dpid_a = "00:00:00:00:00:00:00:01"
+        dpid_x = "00:00:00:00:00:00:00:XX"
+        iface_a = f'{dpid_a}:1'
+        switch_attrs = {
+            'dpid': dpid_a,
+            'enabled': True,
+            'id': dpid_a,
+            'interfaces': {
+                iface_a: {
+                    'enabled': True,
+                    'lldp': True,
+                    'id': iface_a,
+                    'switch': dpid_a,
+                    'name': 's2-eth1',
+                    'port_number': 1
+                }
+            }
+        }
+        self.napp._load_switch(dpid_a, switch_attrs)
+
+        self.assertEqual(len(self.napp.controller.switches), 1)
+        self.assertIn(dpid_a, self.napp.controller.switches)
+        self.assertNotIn(dpid_x, self.napp.controller.switches)
+        switch = self.napp.controller.switches[dpid_a]
+
+        self.assertEqual(switch.id, dpid_a)
+        self.assertEqual(switch.dpid, dpid_a)
+        self.assertTrue(switch.is_enabled())
+        self.assertFalse(switch.is_active())
+
+        self.assertEqual(len(switch.interfaces), 1)
+        self.assertIn(1, switch.interfaces)
+        self.assertNotIn(2, switch.interfaces)
+        interface = switch.interfaces[1]
+        self.assertEqual(interface.id, iface_a)
+        self.assertEqual(interface.switch.id, dpid_a)
+        self.assertEqual(interface.port_number, 1)
+        self.assertTrue(interface.is_enabled())
+        self.assertFalse(interface.is_active())
+        self.assertTrue(interface.lldp)
+        self.assertTrue(interface.uni)
+        self.assertFalse(interface.nni)
+
+    def test_load_switch_attrs(self):
+        """Test _load_switch."""
+        dpid_b = "00:00:00:00:00:00:00:02"
+        iface_b = f'{dpid_b}:1'
+        switch_attrs = {
+            "active": True,
+            "connection": "127.0.0.1:43230",
+            "data_path": "XX Human readable desc of dp",
+            "dpid": "00:00:00:00:00:00:00:02",
+            "enabled": False,
+            "hardware": "Open vSwitch",
+            "id": "00:00:00:00:00:00:00:02",
+            "interfaces": {
+                "00:00:00:00:00:00:00:02:1": {
+                    "active": True,
+                    "enabled": False,
+                    "id": "00:00:00:00:00:00:00:02:1",
+                    "link": "",
+                    "lldp": False,
+                    "mac": "de:58:c3:30:b7:b7",
+                    "metadata": {},
+                    "name": "s2-eth1",
+                    "nni": False,
+                    "port_number": 1,
+                    "speed": 1250000000,
+                    "switch": "00:00:00:00:00:00:00:02",
+                    "type": "interface",
+                    "uni": True
+                },
+            },
+            "manufacturer": "Nicira, Inc.",
+            "metadata": {},
+            "name": "00:00:00:00:00:00:00:04",
+            "ofp_version": "0x04",
+            "serial": "XX serial number",
+            "software": "2.10.7",
+            "type": "switch"
+        }
+
+        self.napp._load_switch(dpid_b, switch_attrs)
+
+        self.assertEqual(len(self.napp.controller.switches), 1)
+        self.assertIn(dpid_b, self.napp.controller.switches)
+
+        switch = self.napp.controller.switches[dpid_b]
+        self.assertEqual(switch.id, dpid_b)
+        self.assertEqual(switch.dpid, dpid_b)
+        self.assertFalse(switch.is_enabled())
+        self.assertFalse(switch.is_active())
+        self.assertEqual(switch.description['manufacturer'], 'Nicira, Inc.')
+        self.assertEqual(switch.description['hardware'], 'Open vSwitch')
+        self.assertEqual(switch.description['software'], '2.10.7')
+        self.assertEqual(switch.description['serial'], 'XX serial number')
+        self.assertEqual(switch.description['data_path'],
+                         'XX Human readable desc of dp')
+
+        self.assertEqual(len(switch.interfaces), 1)
+        self.assertIn(1, switch.interfaces)
+        self.assertNotIn(2, switch.interfaces)
+
+        interface = switch.interfaces[1]
+        self.assertEqual(interface.id, iface_b)
+        self.assertEqual(interface.switch.id, dpid_b)
+        self.assertEqual(interface.port_number, 1)
+        self.assertFalse(interface.is_enabled())
+        self.assertFalse(interface.is_active())
+        self.assertFalse(interface.lldp)
+        self.assertTrue(interface.uni)
+        self.assertFalse(interface.nni)
+
+    def test_load_link(self):
+        """Test _load_link."""
+        dpid_a = "00:00:00:00:00:00:00:01"
+        dpid_b = "00:00:00:00:00:00:00:02"
+        mock_switch_a = get_switch_mock(dpid_a, 0x04)
+        mock_switch_b = get_switch_mock(dpid_b, 0x04)
+        mock_interface_a = get_interface_mock('s1-eth1', 1, mock_switch_a)
+        mock_interface_a.id = dpid_a + ':1'
+        mock_interface_b = get_interface_mock('s2-eth1', 1, mock_switch_b)
+        mock_interface_b.id = dpid_b + ':1'
+        mock_switch_a.interfaces = {1: mock_interface_a}
+        mock_switch_b.interfaces = {1: mock_interface_b}
+        self.napp.controller.switches[dpid_a] = mock_switch_a
+        self.napp.controller.switches[dpid_b] = mock_switch_b
+        link_attrs = {
+            'enabled': True,
+            'endpoint_a': {
+                'switch': dpid_a,
+                'port_number': 1
+            },
+            'endpoint_b': {
+                'switch': dpid_b,
+                'port_number': 1
+            }
+        }
+
+        self.napp._load_link(link_attrs)
+
+        self.assertEqual(len(self.napp.links), 1)
+        link = list(self.napp.links.values())[0]
+
+        self.assertEqual(link.endpoint_a.id, mock_interface_a.id)
+        self.assertEqual(link.endpoint_b.id, mock_interface_b.id)
+        self.assertTrue(mock_interface_a.nni)
+        self.assertTrue(mock_interface_b.nni)
+        self.assertEqual(mock_interface_a.update_link.call_count, 1)
+        self.assertEqual(mock_interface_b.update_link.call_count, 1)
+
+        # test enable/disable
         link_id = '4d42dc08522'
-        mock_switch_a = get_switch_mock(dpid)
-        mock_switch_b = get_switch_mock(dpid_b)
-        mock_interface_a_1 = get_interface_mock('s1-eth1', 1, mock_switch_a)
-        mock_interface_b_1 = get_interface_mock('s2-eth1', 1, mock_switch_b)
-        mock_link = get_link_mock(mock_interface_a_1, mock_interface_b_1)
+        mock_interface_a = get_interface_mock('s1-eth1', 1, mock_switch_a)
+        mock_interface_b = get_interface_mock('s2-eth1', 1, mock_switch_b)
+        mock_link = get_link_mock(mock_interface_a, mock_interface_b)
         mock_link.id = link_id
-        self.napp.links = {link_id: mock_link}
-        self.napp.links_state = {link_id: {'enabled': True}}
-        # enable link
-        self.napp.restore_network_status(mock_link)
-        self.assertEqual(mock_link.enable.call_count, 1)
-
-        # disable link
-        self.napp.links_state = {link_id: {"enabled": False}}
-        self.napp._verified_links = []
-        self.napp.restore_network_status(mock_link)
-        self.assertEqual(mock_link.disable.call_count, 1)
+        with patch('napps.kytos.topology.main.Main._get_link_or_create',
+                   return_value=mock_link):
+            # enable link
+            link_attrs['enabled'] = True
+            self.napp.links = {link_id: mock_link}
+            self.napp._load_link(link_attrs)
+            self.assertEqual(mock_link.enable.call_count, 1)
+            # disable link
+            link_attrs['enabled'] = False
+            self.napp.links = {link_id: mock_link}
+            self.napp._load_link(link_attrs)
+            self.assertEqual(mock_link.disable.call_count, 1)
 
-    def test_fail_restore_link(self):
-        """Test fail restore_link."""
-        dpid = '00:00:00:00:00:00:00:01'
+    @patch('napps.kytos.topology.main.Main._get_link_or_create')
+    def test_fail_load_link(self, get_link_or_create_mock):
+        """Test fail load_link."""
+        dpid_a = '00:00:00:00:00:00:00:01'
         dpid_b = '00:00:00:00:00:00:00:02'
         link_id = '4d42dc08522'
-        link_id_fail = '4cd52'
-        mock_switch_a = get_switch_mock(dpid)
+        mock_switch_a = get_switch_mock(dpid_a)
         mock_switch_b = get_switch_mock(dpid_b)
         mock_interface_a_1 = get_interface_mock('s1-eth1', 1, mock_switch_a)
         mock_interface_b_1 = get_interface_mock('s2-eth1', 1, mock_switch_b)
         mock_link = get_link_mock(mock_interface_a_1, mock_interface_b_1)
         mock_link.id = link_id
         self.napp.links = {link_id: mock_link}
-        self.napp.links_state = {link_id: {"enabled": True}}
-        with self.assertRaises(RestoreError):
-            self.napp._restore_link(link_id_fail)
-
-        self.napp.links_state = {link_id_fail: {"enabled": True}}
-        with self.assertRaises(RestoreError):
-            self.napp._restore_link(link_id_fail)
-
-    def test_fail_restore_switch(self):
-        """Test fail restore_switch."""
-        dpid = '00:00:00:00:00:00:00:01'
-        dpid_fail = '00:00:00:00:00:00:00:06'
-        mock_switch = get_switch_mock(dpid)
-        mock_switch.id = dpid
-        mock_interface = get_interface_mock('s1-eth1', 1, mock_switch)
-        mock_switch.interfaces = {1: mock_interface}
-        self.napp.controller.switche = {dpid: mock_switch}
-        self.napp.switches_state = {dpid: True}
-        self.napp.interfaces_state = {'00:00:00:00:00:00:00:01:1': (True,
-                                                                    True)}
-
+        get_link_or_create_mock.return_value = mock_link
+
+        link_attrs_fail = {
+            'enabled': True,
+            'endpoint_a': {
+                'switch': dpid_a,
+                'port_number': 999
+            },
+            'endpoint_b': {
+                'switch': dpid_b,
+                'port_number': 999
+            }
+        }
         with self.assertRaises(RestoreError):
-            self.napp._restore_switch(dpid_fail)
-
-        self.napp.switches_state = {dpid_fail: True}
+            self.napp._load_link(link_attrs_fail)
+
+        link_attrs_fail = {
+            'enabled': True,
+            'endpoint_a': {
+                'switch': '00:00:00:00:00:00:00:99',
+                'port_number': 1
+            },
+            'endpoint_b': {
+                'switch': '00:00:00:00:00:00:00:77',
+                'port_number': 1
+            }
+        }
         with self.assertRaises(RestoreError):
-            self.napp._restore_switch(dpid_fail)
+            self.napp._load_link(link_attrs_fail)
 
     @patch('napps.kytos.topology.main.Main.save_status_on_storehouse')
     def test_enable_switch(self, mock_save_status):

From 507c0da207800bae05a9ffc2713b9f531db7ec29 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 11 Jun 2021 22:00:39 -0400
Subject: [PATCH 3/3] saving the topology when elements are added and using
 Lock to avoid race conditions

---
 main.py                 | 38 ++++++++++++++++++++++++++++----------
 tests/unit/test_main.py | 23 +++++++++++++++++++----
 2 files changed, 47 insertions(+), 14 deletions(-)

diff --git a/main.py b/main.py
index 85f0c3d..581bb3a 100644
--- a/main.py
+++ b/main.py
@@ -4,6 +4,7 @@
 """
 import time
 from datetime import datetime, timezone
+from threading import Lock
 
 from flask import jsonify, request
 from werkzeug.exceptions import BadRequest, UnsupportedMediaType
@@ -41,6 +42,8 @@ def setup(self):
 
         self.storehouse = StoreHouse(self.controller)
 
+        self._lock = Lock()
+
     def execute(self):
         """Execute once when the napp is running."""
         self._load_network_status()
@@ -145,6 +148,17 @@ def _load_switch(self, switch_id, switch_att):
             interface.lldp = iface_att['lldp']
             switch.update_interface(interface)
             self.update_instance_metadata(interface)
+            name = 'kytos/topology.port.created'
+            event = KytosEvent(name=name, content={
+                                              'switch': switch_id,
+                                              'port': interface.port_number,
+                                              'port_description': {
+                                                  'alias': interface.name,
+                                                  'mac': interface.address,
+                                                  'state': interface.state
+                                                  }
+                                              })
+            self.controller.buffers.app.put(event)
 
     def _load_link(self, link_att):
         dpid_a = link_att['endpoint_a']['switch']
@@ -494,6 +508,7 @@ def handle_new_switch(self, event):
         switch = event.content['switch']
         switch.activate()
         log.debug('Switch %s added to the Topology.', switch.id)
+        self.save_status_on_storehouse()
         self.notify_topology_update()
         self.update_instance_metadata(switch)
         if switch.is_enabled():
@@ -526,6 +541,7 @@ def handle_interface_up(self, event):
     def handle_interface_created(self, event):
         """Update the topology based on a Port Create event."""
         self.handle_interface_up(event)
+        self.save_status_on_storehouse()
 
     def handle_interface_down(self, event):
         """Update the topology based on a Port Modify event.
@@ -639,6 +655,7 @@ def add_links(self, event):
         interface_b.nni = True
 
         self.notify_topology_update()
+        self.save_status_on_storehouse()
 
     # def add_host(self, event):
     #    """Update the topology with a new Host."""
@@ -661,16 +678,17 @@ def add_links(self, event):
     @listen_to('.*.network_status.updated')
     def save_status_on_storehouse(self, event=None):
         """Save the network administrative status using storehouse."""
-        status = self._get_switches_dict()
-        status['id'] = 'network_status'
-        if event:
-            content = event.content
-            log.info(f"Storing the administrative state of the"
-                     f" {content['attribute']} attribute to"
-                     f" {content['state']} in the interfaces"
-                     f" {content['interface_ids']}")
-        status.update(self._get_links_dict())
-        self.storehouse.save_status(status)
+        with self._lock:
+            status = self._get_switches_dict()
+            status['id'] = 'network_status'
+            if event:
+                content = event.content
+                log.info(f"Storing the administrative state of the"
+                         f" {content['attribute']} attribute to"
+                         f" {content['state']} in the interfaces"
+                         f" {content['interface_ids']}")
+            status.update(self._get_links_dict())
+            self.storehouse.save_status(status)
 
     def notify_switch_enabled(self, dpid):
         """Send an event to notify that a switch is enabled."""
diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index 3bd7704..0aa9dbe 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -320,8 +320,11 @@ def test_load_network_status_fail_link(self, *args):
         error = 'Error loading link: xpto'
         mock_log.error.assert_called_with(error)
 
-    def test_load_switch(self):
+    @patch('napps.kytos.topology.main.KytosEvent')
+    @patch('kytos.core.buffers.KytosEventBuffer.put')
+    def test_load_switch(self, *args):
         """Test _load_switch."""
+        (mock_buffers_put, mock_event) = args
         dpid_a = "00:00:00:00:00:00:00:01"
         dpid_x = "00:00:00:00:00:00:00:XX"
         iface_a = f'{dpid_a}:1'
@@ -355,6 +358,9 @@ def test_load_switch(self):
         self.assertEqual(len(switch.interfaces), 1)
         self.assertIn(1, switch.interfaces)
         self.assertNotIn(2, switch.interfaces)
+        mock_event.assert_called()
+        mock_buffers_put.assert_called()
+
         interface = switch.interfaces[1]
         self.assertEqual(interface.id, iface_a)
         self.assertEqual(interface.switch.id, dpid_a)
@@ -992,9 +998,12 @@ def test_delete_link_metadata(self, mock_metadata_changes):
 
     @patch('napps.kytos.topology.main.Main.notify_topology_update')
     @patch('napps.kytos.topology.main.Main.update_instance_metadata')
+    @patch('napps.kytos.topology.main.StoreHouse.save_status')
     def test_handle_new_switch(self, *args):
         """Test handle_new_switch."""
-        (mock_instance_metadata, mock_notify_topology_update) = args
+        (mock_instance_metadata, mock_notify_topology_update,
+         mock_save_status) = args
+        mock_save_status.return_value = True
         mock_event = MagicMock()
         mock_switch = create_autospec(Switch)
         mock_event.content['switch'] = mock_switch
@@ -1025,8 +1034,11 @@ def test_handle_interface_up(self, *args):
         mock_instance_metadata.assert_called()
 
     @patch('napps.kytos.topology.main.Main.handle_interface_up')
-    def test_handle_interface_created(self, mock_handle_interface_up):
+    @patch('napps.kytos.topology.main.StoreHouse.save_status')
+    def test_handle_interface_created(self, *args):
         """Test handle interface created."""
+        (mock_handle_interface_up, mock_save_status) = args
+        mock_save_status.return_value = True
         mock_event = MagicMock()
         self.napp.handle_interface_created(mock_event)
         mock_handle_interface_up.assert_called()
@@ -1099,9 +1111,12 @@ def test_interface_link_down(self, *args):
 
     @patch('napps.kytos.topology.main.Main._get_link_or_create')
     @patch('napps.kytos.topology.main.Main.notify_topology_update')
+    @patch('napps.kytos.topology.main.StoreHouse.save_status')
     def test_add_links(self, *args):
         """Test add_links."""
-        (mock_notify_topology_update, mock_get_link_or_create) = args
+        (mock_notify_topology_update, mock_get_link_or_create,
+         mock_save_status) = args
+        mock_save_status.return_value = True
         mock_event = MagicMock()
         self.napp.add_links(mock_event)
         mock_get_link_or_create.assert_called()
